<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Focus Flow Calendar</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light dark;
      --surface: #0b0b0f;
      --surface-alt: #15151f;
      --text: #f2f3f5;
      --muted: rgba(242, 243, 245, 0.65);
      --accent: #6a5acd;
      --accent-soft: rgba(106, 90, 205, 0.16);
      --grid-line: rgba(255, 255, 255, 0.06);
      --shadow: 0 24px 48px rgba(0, 0, 0, 0.25);
      --radius-lg: 22px;
      --radius-md: 16px;
      --radius-sm: 12px;
      --timeline-minute-height: 0.75px;
      --timeline-gutter: 72px;
      --mission-gold: #ffc75f;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top right, rgba(106, 90, 205, 0.12), transparent 45%),
                  radial-gradient(circle at bottom left, rgba(255, 105, 180, 0.18), transparent 55%),
                  var(--surface);
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.4;
      padding: 40px clamp(24px, 5vw, 72px);
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    .app-shell {
      width: min(1400px, 100%);
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .app-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
    }

    .app-header h1 {
      margin: 0;
      font-family: 'Space Grotesk', 'Inter', sans-serif;
      font-size: clamp(28px, 4vw, 44px);
      letter-spacing: -0.02em;
    }

    .tagline {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 15px;
      max-width: 420px;
    }

    .time-block {
      display: grid;
      gap: 6px;
      text-align: right;
      font-size: 15px;
      color: var(--muted);
      padding: 12px 18px;
      background: rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
    }

    .time-block .current-time {
      font-size: 20px;
      color: var(--text);
      font-weight: 600;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      gap: 16px;
    }

    .control-buttons {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .btn {
      appearance: none;
      border: none;
      padding: 12px 18px;
      border-radius: var(--radius-sm);
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
      box-shadow: 0 18px 30px rgba(106, 90, 205, 0.35);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(106, 90, 205, 0.4);
    }

    .btn-ghost {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .calendar-card {
      background: rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 20px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(18px);
      position: relative;
      overflow: visible;
    }

    .calendar-scroll {
      display: flex;
      flex-direction: column;
      gap: 56px;
      position: relative;
    }

    .calendar-layout {
      display: flex;
      gap: 28px;
      align-items: flex-start;
    }

    .main-calendar {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
    }

    .calendar-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
    }

    .calendar-toolbar .year-label {
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .btn-icon {
      padding: 10px;
      width: 38px;
      height: 38px;
      border-radius: 50%;
      justify-content: center;
    }

    .btn-icon svg {
      width: 14px;
      height: 14px;
    }

    .year-view-card {
      flex: 0 0 clamp(260px, 26vw, 320px);
      display: flex;
      flex-direction: column;
      gap: 16px;
      position: sticky;
      top: clamp(24px, 6vh, 56px);
      max-height: calc(100vh - clamp(48px, 10vh, 120px));
      overflow: hidden;
    }

    .year-view-scroll {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 18px;
      overflow-y: auto;
      padding-right: 6px;
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
    }

    .year-view-scroll::-webkit-scrollbar {
      width: 6px;
    }

    .year-view-scroll::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.24);
      border-radius: 999px;
    }

    .mini-month {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .mini-month-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: rgba(255, 255, 255, 0.55);
    }

    .mini-month-header .mini-year {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.38);
      letter-spacing: 0.14em;
    }

    .mini-weekday-row {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 4px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: rgba(255, 255, 255, 0.32);
    }

    .mini-grid {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 4px;
    }

    .mini-day {
      position: relative;
      aspect-ratio: 1 / 1;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.7);
      overflow: hidden;
      isolation: isolate;
      user-select: none;
    }

    .mini-day:not(.empty) {
      cursor: pointer;
    }

    .mini-day-number {
      position: relative;
      z-index: 3;
    }

    .mini-day.weekend {
      background: rgba(255, 255, 255, 0.08);
    }

    .mini-day.empty {
      background: transparent;
      border-color: transparent;
      color: transparent;
    }

    .mini-day.today {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106, 90, 205, 0.45);
      color: var(--accent);
      font-weight: 600;
    }

    .mini-focus-stack {
      position: absolute;
      inset: 3px;
      display: flex;
      flex-direction: column;
      gap: 3px;
      pointer-events: none;
      z-index: 2;
    }

    .mini-focus-block {
      flex: 1;
      border-radius: 8px;
      border: 1px solid var(--mini-focus-border, rgba(255, 255, 255, 0.14));
      background:
        linear-gradient(135deg, var(--mini-focus-strong, rgba(255, 255, 255, 0.12)), var(--mini-focus-soft, rgba(255, 255, 255, 0.04)));
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.28);
      opacity: 0.9;
      transition: transform 0.2s ease, opacity 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      pointer-events: auto;
      position: relative;
      overflow: hidden;
    }

    .mini-focus-block:hover,
    .mini-focus-block:focus-visible {
      opacity: 1;
      transform: translateY(-1px);
      box-shadow: 0 14px 26px rgba(0, 0, 0, 0.35);
      border-color: var(--mini-focus-border, rgba(255, 255, 255, 0.28));
      outline: none;
    }

    .mini-day.focus-range {
      border-color: rgba(106, 90, 205, 0.45);
      box-shadow: 0 0 0 2px rgba(106, 90, 205, 0.35);
    }

    @media (max-width: 1180px) {
      .calendar-layout {
        flex-direction: column;
      }

      .year-view-card {
        position: static;
        max-height: none;
        width: 100%;
      }

      .year-view-scroll {
        max-height: none;
      }
    }

    .month-block {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .month-divider {
      position: relative;
      height: 36px;
      display: flex;
      align-items: flex-end;
      margin-bottom: 8px;
    }

    .month-divider::before {
      display: none;
    }

    .month-label {
      position: absolute;
      left: 0;
      top: -8px;
      font-family: 'Space Grotesk', 'Inter', sans-serif;
      font-size: clamp(26px, 6vw, 48px);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.28em;
      color: rgba(255, 255, 255, 0.1);
      pointer-events: none;
    }

    .time-field {
      position: relative;
    }

    .time-field-display {
      width: 100%;
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 16px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font: inherit;
      font-size: 16px;
      letter-spacing: 0.04em;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .time-field-display:hover,
    .time-field-display:focus-visible {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 24px 44px rgba(0, 0, 0, 0.35);
      outline: none;
    }

    .time-field-display::after {
      content: '▾';
      font-size: 12px;
      opacity: 0.7;
    }

    .time-field-panel {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 10px);
      padding: 8px;
      border-radius: var(--radius-md);
      background: rgba(21, 21, 31, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 28px 52px rgba(0, 0, 0, 0.5);
      opacity: 0;
      pointer-events: none;
      transform: translateY(-8px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 40;
    }

    .time-field-panel.open {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    .time-picker {
      position: relative;
      display: grid;
      gap: 6px;
      padding: 12px;
      border-radius: var(--radius-md);
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      max-height: 220px;
      overflow-y: auto;
      scroll-snap-type: y mandatory;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .time-picker:focus {
      outline: 2px solid rgba(106, 90, 205, 0.65);
      outline-offset: 2px;
    }

    .time-option {
      appearance: none;
      border: none;
      background: transparent;
      color: var(--text);
      font: inherit;
      font-size: 18px;
      letter-spacing: 0.04em;
      padding: 12px 16px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      text-align: left;
      scroll-snap-align: center;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    }

    .time-option:hover,
    .time-option:focus-visible {
      background: rgba(255, 255, 255, 0.12);
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.28);
      outline: none;
    }

    .time-option.selected {
      background: linear-gradient(135deg, rgba(106, 90, 205, 0.4), rgba(106, 90, 205, 0.15));
      box-shadow: 0 18px 30px rgba(106, 90, 205, 0.25);
    }

    .time-option[data-value=''] {
      font-size: 15px;
      color: rgba(255, 255, 255, 0.72);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .mini-tooltip {
      position: fixed;
      z-index: 2000;
      padding: 8px 12px;
      border-radius: 10px;
      background: rgba(21, 21, 31, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--text);
      font-size: 12px;
      letter-spacing: 0.05em;
      pointer-events: none;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.4);
      opacity: 0;
      transform: translate(-50%, -12px);
      transition: opacity 0.15s ease;
      white-space: pre-line;
    }

    .mini-tooltip.visible {
      opacity: 1;
    }

    .weekday-row {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 12px;
      color: var(--muted);
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    .weekday-row span.weekend {
      color: rgba(255, 255, 255, 0.55);
    }

    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 10px;
      overflow: visible;
    }

    .day {
      position: relative;
      background: rgba(11, 11, 15, 0.6);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.05);
      min-height: 130px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: transform 0.35s cubic-bezier(0.22, 1, 0.36, 1),
                  box-shadow 0.35s cubic-bezier(0.22, 1, 0.36, 1),
                  border 0.2s ease,
                  background 0.2s ease;
      overflow: visible;
      transform-origin: center;
      will-change: transform;
      z-index: 1;
    }

    .day::before {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: inherit;
      background: radial-gradient(circle, rgba(106, 90, 205, 0.28), transparent 70%);
      opacity: 0;
      pointer-events: none;
      transform: scale(0.92);
    }

    .day::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      box-shadow: 0 0 0 0 rgba(106, 90, 205, 0.4);
      opacity: 0;
      transition: opacity 0.35s ease, box-shadow 0.35s ease;
      pointer-events: none;
    }

    @keyframes day-pulse {
      0% {
        opacity: 0.9;
        transform: scale(0.88);
      }
      45% {
        opacity: 0.55;
        transform: scale(1.1);
      }
      72% {
        opacity: 0.25;
        transform: scale(1.18);
      }
      100% {
        opacity: 0;
        transform: scale(1.24);
      }
    }

    .day.highlight-pulse {
      z-index: 7;
    }

    .day.highlight-pulse::before {
      opacity: 1;
      animation: day-pulse 1.85s ease-out forwards;
    }

    .day:is(:hover, .drag-over, .show-flyout) {
      transform: scale(1.08);
      border-color: rgba(255, 255, 255, 0.18);
      background: rgba(21, 21, 31, 0.82);
      z-index: 5;
      box-shadow: 0 28px 60px rgba(0, 0, 0, 0.45);
    }

    .day:is(:hover, .drag-over, .show-flyout)::after {
      opacity: 1;
      box-shadow: 0 0 0 8px rgba(106, 90, 205, 0.18);
    }

    .day.empty {
      background: rgba(255, 255, 255, 0.02);
      border-style: dashed;
      border-color: rgba(255, 255, 255, 0.05);
    }

    .day.weekend {
      background: rgba(21, 21, 31, 0.6);
    }

    .day.weekend.empty {
      background: rgba(255, 255, 255, 0.04);
    }

    .day.weekend:is(:hover, .drag-over, .show-flyout) {
      background: rgba(27, 27, 39, 0.88);
    }

    .day-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .day-number {
      font-weight: 700;
      font-size: 16px;
      letter-spacing: 0.06em;
    }

    .day-number .weekday {
      display: block;
      font-size: 11px;
      font-weight: 500;
      color: var(--muted);
      letter-spacing: 0.15em;
      margin-top: 4px;
    }

    .add-task-btn {
      appearance: none;
      border: none;
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-size: 18px;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .add-task-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      transform: translateY(-1px);
    }

    .task-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
      min-height: 24px;
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.18) transparent;
    }

    .task-list::-webkit-scrollbar {
      width: 6px;
    }

    .task-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.18);
      border-radius: 999px;
    }

    .task-preview {
      display: grid;
      gap: 4px;
      min-height: 32px;
      pointer-events: none;
    }

    .task-preview-bar {
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.14);
      position: relative;
      overflow: hidden;
    }

    .task-preview-bar.mission-critical {
      box-shadow: none;
    }

    .task-preview-bar::after {
      content: '';
      position: absolute;
      inset: 0;
      opacity: 0.9;
      background: inherit;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.28);
    }

    .task-preview-empty {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.35);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .task-flyout {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translate(-50%, 12px);
      width: clamp(260px, 32vw, 360px);
      max-height: clamp(220px, 52vh, 480px);
      padding: 20px;
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(18, 18, 28, 0.96);
      box-shadow: 0 36px 72px rgba(0, 0, 0, 0.52);
      backdrop-filter: blur(20px);
      opacity: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 16px;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 40;
    }

    .day:is(:hover, .drag-over, .show-flyout) .task-flyout {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, 0);
    }

    .task-flyout .task-list {
      max-height: clamp(220px, 52vh, 480px);
      overflow: auto;
      padding-right: 4px;
    }

    .task-flyout .empty-state {
      text-align: center;
      padding: 16px 0;
      color: rgba(255, 255, 255, 0.45);
    }

    .task-timeline {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-top: 12px;
      padding: 16px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(18, 18, 28, 0.92);
      box-shadow: 0 18px 38px rgba(0, 0, 0, 0.42);
      overflow: hidden;
      z-index: 2;
    }

    .task-timeline::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    .day.drag-over .task-timeline::after {
      box-shadow: inset 0 0 0 1px rgba(106, 90, 205, 0.35);
    }

    .timeline-scroller {
      position: relative;
      overflow-y: auto;
      max-height: 540px;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(12, 12, 18, 0.75);
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.18) transparent;
    }

    .timeline-scroller::-webkit-scrollbar {
      width: 6px;
    }

    .timeline-scroller::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.18);
      border-radius: 999px;
    }

    .timeline-content {
      position: relative;
      padding: 12px 12px 12px calc(var(--timeline-gutter) + 12px);
      min-height: calc(1440 * var(--timeline-minute-height));
    }

    .timeline-hour-marker {
      position: absolute;
      left: 0;
      right: 0;
      height: 0;
      pointer-events: none;
    }

    .timeline-hour-marker::after {
      content: '';
      position: absolute;
      left: var(--timeline-gutter);
      right: 0;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      opacity: 0.6;
    }

    .timeline-hour-marker span {
      position: absolute;
      left: 0;
      transform: translateY(-50%);
      font-size: 11px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.42);
    }

    .timeline-task {
      position: absolute;
      left: var(--timeline-gutter);
      right: 12px;
      border-radius: 16px;
      padding: 12px 16px 12px 20px;
      background:
        linear-gradient(135deg, var(--task-color-strong, rgba(255, 255, 255, 0.2)), var(--task-color-soft, rgba(255, 255, 255, 0.06)));
      border: 1px solid var(--task-outline, rgba(255, 255, 255, 0.18));
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 6px;
      cursor: grab;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      overflow: hidden;
    }

    .timeline-task::before {
      content: '';
      position: absolute;
      inset: 0 auto 0 0;
      width: 4px;
      border-radius: 16px 0 0 16px;
      background: var(--task-pill, rgba(255, 255, 255, 0.5));
      opacity: 0.9;
    }

    .timeline-task:active {
      cursor: grabbing;
    }

    .timeline-task:hover,
    .timeline-task:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.48);
      border-color: var(--task-outline, rgba(255, 255, 255, 0.32));
      outline: none;
    }

    .timeline-task.is-dragging {
      opacity: 0.6;
      cursor: grabbing;
    }

    .timeline-task.mission-critical {
      border-color: rgba(255, 199, 95, 0.8);
      box-shadow: 0 28px 58px rgba(255, 199, 95, 0.25);
    }

    .timeline-task-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
    }

    .timeline-task-name {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .timeline-task-time {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: rgba(255, 255, 255, 0.72);
      white-space: nowrap;
    }

    .timeline-task-details {
      opacity: 0;
      max-height: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, max-height 0.2s ease;
      display: grid;
      gap: 6px;
    }

    .timeline-task:hover .timeline-task-details,
    .timeline-task:focus-visible .timeline-task-details {
      opacity: 1;
      max-height: 240px;
      pointer-events: auto;
    }

    .timeline-detail-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: rgba(255, 255, 255, 0.7);
    }

    .timeline-detail {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .timeline-detail.mission-critical {
      color: var(--mission-gold);
    }

    .timeline-note {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.4;
    }

    .timeline-empty {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.4);
      pointer-events: none;
    }

    .focus-range {
      border-color: rgba(106, 90, 205, 0.45);
      box-shadow: 0 0 0 2px rgba(106, 90, 205, 0.35);
    }

    .focus-range::after {
      opacity: 1;
      box-shadow: 0 0 0 6px rgba(106, 90, 205, 0.18);
    }

    .focus-range .day-number {
      color: var(--accent);
    }

    .task-card {
      position: relative;
      background:
        linear-gradient(135deg, var(--task-tint-strong, rgba(255, 255, 255, 0.16)), var(--task-tint-soft, rgba(255, 255, 255, 0.05))),
        rgba(15, 15, 24, 0.78);
      border-radius: 18px;
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      cursor: grab;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      min-height: 52px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 22px 40px rgba(0, 0, 0, 0.42);
      overflow: hidden;
    }

    .task-card::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(150deg, rgba(255, 255, 255, 0.1), transparent);
      opacity: 0.7;
      pointer-events: none;
    }

    .task-card::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 4px;
      background: var(--task-outline, rgba(255, 255, 255, 0.24));
      opacity: 0.85;
      pointer-events: none;
    }

    .task-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 28px 50px rgba(0, 0, 0, 0.5);
      border-color: var(--task-outline, rgba(255, 255, 255, 0.24));
      background:
        linear-gradient(135deg, var(--task-tint-strong, rgba(255, 255, 255, 0.2)), var(--task-tint-soft, rgba(255, 255, 255, 0.08))),
        rgba(18, 18, 28, 0.88);
    }

    .task-card:active {
      cursor: grabbing;
      transform: scale(0.99);
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.45);
    }

    .task-card.is-dragging {
      opacity: 0.65;
      transform: scale(0.97);
      box-shadow: 0 22px 38px rgba(0, 0, 0, 0.5);
    }

    .task-card.mission-critical {
      border-color: var(--task-outline, rgba(255, 255, 255, 0.24));
      box-shadow: 0 22px 44px rgba(0, 0, 0, 0.35);
    }

    .task-title {
      font-weight: 600;
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: nowrap;
      position: relative;
      z-index: 1;
    }

    .task-title .task-name {
      flex: 1 1 auto;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      letter-spacing: 0.01em;
    }

    .task-time {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.68);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      margin-left: auto;
    }

    .task-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
      background: var(--task-dot, rgba(255, 255, 255, 0.65));
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.12);
    }

    .task-meta {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.68);
      width: 100%;
      position: relative;
      z-index: 1;
    }

    .task-detail-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .task-detail {
      display: inline-flex;
      align-items: center;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: rgba(255, 255, 255, 0.6);
    }

    .task-detail:not(:first-child)::before {
      content: '•';
      margin-right: 8px;
      color: rgba(255, 255, 255, 0.35);
    }

    .task-detail.mission-critical {
      color: rgba(255, 255, 255, 0.68);
      text-shadow: none;
    }

    .task-note-line {
      max-width: 100%;
      white-space: normal;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.45;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.78);
    }

    .day.today {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106, 90, 205, 0.3);
    }

    .day.today .day-number {
      color: var(--accent);
    }

    .focus-overlay-stack {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      align-content: stretch;
      gap: 6px;
      padding: 6px;
    }

    .focus-overlay {
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.12);
      min-height: 12px;
      mix-blend-mode: screen;
    }

    .focus-badges {
      display: none;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      font-size: 11px;
      letter-spacing: 0.08em;
    }

    .focus-badges.active {
      display: flex;
    }

    .focus-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 16px;
      border-radius: 999px;
      background:
        linear-gradient(135deg, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0.04));
      border: 1px solid rgba(255, 255, 255, 0.18);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
      box-shadow: 0 20px 36px rgba(0, 0, 0, 0.4);
    }

    .focus-badge:hover,
    .focus-badge:focus-visible {
      background:
        linear-gradient(135deg, rgba(255, 255, 255, 0.28), rgba(255, 255, 255, 0.08));
      color: var(--text);
      transform: translateY(-1px);
      box-shadow: 0 26px 44px rgba(0, 0, 0, 0.48);
      outline: none;
    }

    .focus-badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-flex;
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.14);
    }

    .day-progress {
      position: absolute;
      left: 0;
      bottom: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent), rgba(255, 105, 180, 0.9));
      border-radius: 0 4px 0 0;
      pointer-events: none;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(8, 8, 12, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 24px;
    }

    .modal-backdrop.open {
      display: flex;
    }

    .modal {
      width: min(420px, 100%);
      background: rgba(14, 14, 20, 0.95);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 24px;
      box-shadow: 0 28px 60px rgba(0, 0, 0, 0.4);
      display: grid;
      gap: 18px;
    }

    .modal h2 {
      margin: 0;
      font-size: 22px;
    }

    .modal form {
      display: grid;
      gap: 14px;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field label {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .field input,
    .field textarea,
    .field select {
      width: 100%;
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-size: 14px;
      font-family: inherit;
    }

    #task-category,
    #task-category option {
      color: #ffffff;
    }

    #task-category option {
      background-color: rgba(21, 21, 31, 0.96);
    }

    .field textarea {
      min-height: 80px;
      resize: vertical;
    }

    .category-select-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .btn-compact {
      padding: 8px 12px;
      font-size: 12px;
      letter-spacing: 0.08em;
    }

    .category-preview {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .category-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid transparent;
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      font-size: 13px;
      letter-spacing: 0.02em;
      color: var(--text);
    }

    .category-chip:hover,
    .category-chip:focus-visible {
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.28);
      background: rgba(255, 255, 255, 0.12);
      outline: none;
    }

    .category-chip[aria-pressed="true"] {
      border-color: rgba(255, 255, 255, 0.45);
      background: rgba(255, 255, 255, 0.18);
    }

    .category-chip-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.2);
    }

    .hidden {
      display: none !important;
    }

    .color-swatch-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .color-swatch {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid transparent;
      background: var(--swatch-color);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
      padding: 0;
      appearance: none;
    }

    .color-swatch:hover,
    .color-swatch:focus-visible {
      transform: scale(1.05);
      outline: none;
    }

    .color-swatch[aria-pressed="true"] {
      border-color: rgba(255, 255, 255, 0.85);
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.25);
    }

    .checkbox-row {
      display: flex;
      align-items: center;
    }

    .checkbox-control {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      color: var(--text);
      text-transform: none;
      letter-spacing: 0;
    }

    .checkbox-control .mission-critical-text {
      color: var(--mission-gold);
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .checkbox-control input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
    }

    .modal-actions {
      display: flex;
      justify-content: space-between;
      gap: 12px;
    }

    .modal-actions .spacer {
      flex: 1;
    }

    .empty-state {
      color: var(--muted);
      font-size: 13px;
    }

  </style>
</head>
<body>
  <div class="app-shell">
    <header class="app-header">
      <div>
        <h1>Focus Flow Calendar</h1>
        <p class="tagline">Design a bold rhythm for your week. Sequence deep work, creative sprints, and essential tasks with intent.</p>
      </div>
      <div class="time-block">
        <span class="current-date"></span>
        <span class="current-time"></span>
      </div>
    </header>

    <section class="controls">
      <div class="control-buttons">
        <button class="btn btn-ghost" id="reset-calendar" title="Reset to today">Today</button>
        <button class="btn btn-primary" id="add-focus">+ Focus Block</button>
      </div>
    </section>

    <section class="calendar-layout">
      <section class="calendar-card main-calendar">
        <div class="calendar-toolbar">
          <button type="button" class="btn btn-ghost btn-icon" data-year-nav="-1" aria-label="Previous year">&larr;</button>
          <span class="year-label" data-year-label></span>
          <button type="button" class="btn btn-ghost btn-icon" data-year-nav="1" aria-label="Next year">&rarr;</button>
        </div>
        <div class="calendar-scroll" id="calendar-grid"></div>
      </section>

      <aside class="calendar-card year-view-card">
        <div class="calendar-toolbar">
          <button type="button" class="btn btn-ghost btn-icon" data-year-nav="-1" aria-label="Previous year">&larr;</button>
          <span class="year-label" data-year-label></span>
          <button type="button" class="btn btn-ghost btn-icon" data-year-nav="1" aria-label="Next year">&rarr;</button>
        </div>
        <div class="year-view-scroll" id="year-view"></div>
      </aside>
    </section>
  </div>

  <div class="modal-backdrop" id="task-modal">
    <div class="modal">
      <h2 id="task-modal-title">Plan a task</h2>
      <form id="task-form">
        <div class="field">
          <label for="task-title">Task</label>
          <input type="text" id="task-title" name="title" placeholder="What will you tackle?" required>
        </div>
        <div class="field">
          <label for="task-category">Category</label>
          <div class="category-select-group">
            <select id="task-category" name="category"></select>
            <button type="button" class="btn btn-ghost btn-compact" id="delete-category">Delete category</button>
          </div>
          <div class="category-preview" id="category-preview"></div>
        </div>
        <div class="field hidden" id="new-category-name-field">
          <label for="new-category-name">New category</label>
          <input type="text" id="new-category-name" name="newCategoryName" placeholder="Category name">
        </div>
        <div class="field hidden" id="new-category-color-field">
          <label>Base colour</label>
          <div class="color-swatch-row" id="category-color-options"></div>
          <input type="hidden" id="new-category-color" name="newCategoryColor">
        </div>
        <div class="field">
          <label for="task-start-display">Start time</label>
          <div class="time-field" id="task-start-field">
            <button type="button" class="time-field-display" id="task-start-display" aria-haspopup="listbox" aria-expanded="false" aria-controls="task-start-picker">No start time</button>
            <div class="time-field-panel" id="task-start-panel" hidden>
              <div class="time-picker" id="task-start-picker" role="listbox" aria-label="Start time" tabindex="-1"></div>
            </div>
          </div>
          <input type="hidden" id="task-start" name="start">
        </div>
        <div class="field">
          <label for="task-duration-display">Time allocation</label>
          <div class="time-field" id="task-duration-field">
            <button type="button" class="time-field-display" id="task-duration-display" aria-haspopup="listbox" aria-expanded="false" aria-controls="task-duration-picker">No duration</button>
            <div class="time-field-panel" id="task-duration-panel" hidden>
              <div class="time-picker" id="task-duration-picker" role="listbox" aria-label="Time allocation" tabindex="-1"></div>
            </div>
          </div>
          <input type="hidden" id="task-duration" name="duration">
        </div>
        <div class="checkbox-row">
          <label class="checkbox-control">
            <input type="checkbox" id="task-mission-critical" name="missionCritical">
            <span class="mission-critical-text">Mission critical</span>
          </label>
        </div>
        <div class="field">
          <label for="task-notes">Notes</label>
          <textarea id="task-notes" name="notes" placeholder="Context, deliverables or links..."></textarea>
        </div>
        <div class="modal-actions">
          <button type="button" class="btn btn-ghost" id="task-cancel">Cancel</button>
          <span class="spacer"></span>
          <button type="button" class="btn btn-ghost" id="task-delete" style="display:none;">Delete</button>
          <button type="submit" class="btn btn-primary">Save Task</button>
        </div>
      </form>
    </div>
  </div>

  <div class="modal-backdrop" id="focus-modal">
    <div class="modal">
      <h2 id="focus-modal-title">New focus block</h2>
      <form id="focus-form">
        <div class="field">
          <label for="focus-name">Project / Intention</label>
          <input type="text" id="focus-name" name="name" placeholder="Filming + editing ads" required>
        </div>
        <div class="field">
          <label for="focus-start">Start date</label>
          <input type="date" id="focus-start" name="start" required>
        </div>
        <div class="field">
          <label for="focus-end">Wrap date</label>
          <input type="date" id="focus-end" name="end" required>
        </div>
        <div class="field">
          <label for="focus-color">Colour</label>
          <input type="color" id="focus-color" name="color" value="#ff6f91">
        </div>
        <div class="modal-actions">
          <button type="button" class="btn btn-ghost" id="focus-cancel">Cancel</button>
          <span class="spacer"></span>
          <button type="button" class="btn btn-ghost" id="focus-delete" style="display:none;">Delete</button>
          <button type="submit" class="btn btn-primary">Save Focus</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    const storageKey = 'focus-flow-calendar-state-v2';
    const legacyStorageKey = 'focus-flow-calendar-state-v1';
    const categoryPalette = [
      '#FF6F91',
      '#FF9671',
      '#FFC75F',
      '#F9F871',
      '#7AD3FF',
      '#6A5ACD',
      '#4CAF50',
      '#F45D01',
      '#FF5F7E',
      '#50B5FF'
    ];

    const startTimeOptions = Array.from({ length: (24 * 60) / 15 }, (_, index) => {
      const totalMinutes = index * 15;
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    });

    const durationOptions = [
      { value: 5, label: '5 minutes' },
      { value: 15, label: '15 minutes' },
      { value: 30, label: '30 minutes' },
      { value: 60, label: '1 hour' },
      { value: 120, label: '2 hours' },
      { value: 180, label: '3 hours' },
      { value: 240, label: '4 hours' },
      { value: 300, label: '5 hours' }
    ];

    const MINUTES_IN_DAY = 24 * 60;
    const TIMELINE_MINUTE_HEIGHT = 0.75;
    document.documentElement.style.setProperty('--timeline-minute-height', `${TIMELINE_MINUTE_HEIGHT}px`);

    function defaultCategories() {
      return [
        { id: 1, name: 'General', color: '#6A5ACD' },
        { id: 2, name: 'Deep Work', color: '#FF6F91' },
        { id: 3, name: 'Admin', color: '#FFC75F' }
      ];
    }

    const defaultState = () => {
      const categories = defaultCategories().map((cat) => ({ ...cat }));
      return {
        tasks: {},
        projects: [],
        categories,
        nextTaskId: 1,
        nextProjectId: 1,
        nextCategoryId: categories.length + 1
      };
    };

    function loadState() {
      try {
        let raw = localStorage.getItem(storageKey);
        let migratedFromLegacy = false;
        if (!raw) {
          raw = localStorage.getItem(legacyStorageKey);
          migratedFromLegacy = Boolean(raw);
        }
        if (!raw) return defaultState();
        const parsed = JSON.parse(raw);
        if (!parsed.tasks || typeof parsed.tasks !== 'object') parsed.tasks = {};
        if (!Array.isArray(parsed.projects)) parsed.projects = [];
        if (!Array.isArray(parsed.categories)) {
          parsed.categories = defaultCategories().map((cat) => ({ ...cat }));
        }
        if (!parsed.nextTaskId) parsed.nextTaskId = 1;
        if (!parsed.nextProjectId) parsed.nextProjectId = 1;
        if (!parsed.nextCategoryId) {
          const maxId = parsed.categories.reduce((max, cat) => Math.max(max, Number(cat.id) || 0), 0);
          parsed.nextCategoryId = maxId + 1;
        }
        migrateTaskData(parsed);
        if (migratedFromLegacy) {
          try {
            localStorage.removeItem(legacyStorageKey);
            localStorage.setItem(storageKey, JSON.stringify(parsed));
          } catch (saveErr) {
            console.warn('Unable to persist migrated data', saveErr);
          }
        }
        return parsed;
      } catch (err) {
        console.error('Failed to parse state', err);
        return defaultState();
      }
    }

    function pickCategoryColor(state, fallback) {
      if (fallback) return fallback;
      const used = new Set(
        state.categories
          .map((cat) => (typeof cat.color === 'string' ? cat.color.toLowerCase() : null))
          .filter(Boolean)
      );
      for (const color of categoryPalette) {
        if (!used.has(color.toLowerCase())) return color;
      }
      return categoryPalette[state.categories.length % categoryPalette.length];
    }

    function migrateTaskData(state) {
      const categoriesByName = new Map();
      state.categories = state.categories.map((category, index) => {
        const name = (category.name || '').trim() || `Category ${index + 1}`;
        const id = Number(category.id) || state.nextCategoryId++;
        const normalized = { id, name, color: category.color || categoryPalette[index % categoryPalette.length] };
        categoriesByName.set(name.toLowerCase(), normalized);
        return normalized;
      });

      const ensureCategory = (name, colorHint) => {
        const key = name.toLowerCase();
        if (categoriesByName.has(key)) return categoriesByName.get(key);
        const category = {
          id: state.nextCategoryId++,
          name,
          color: pickCategoryColor(state, colorHint)
        };
        state.categories.push(category);
        categoriesByName.set(key, category);
        return category;
      };

      const generalCategory = ensureCategory('General', '#6A5ACD');

      Object.keys(state.tasks).forEach((dateKey) => {
        const tasks = Array.isArray(state.tasks[dateKey]) ? state.tasks[dateKey] : [];
        tasks.forEach((task) => {
          if (!task || typeof task !== 'object') return;
          task.title = (task.title || '').trim();
          if (!task.title) task.title = 'Untitled task';

          if (task.priority === 'high' && !task.missionCritical) {
            task.missionCritical = true;
          }
          delete task.priority;

          let categoryName = (task.category || '').trim();
          if (!categoryName) {
            categoryName = generalCategory.name;
          }
          const category = ensureCategory(categoryName, task.color);
          task.category = category.name;

          if (task.start && typeof task.start === 'string') {
            task.start = task.start.trim();
          }
          if (!task.start) {
            delete task.start;
          }

          if (task.duration !== undefined && task.duration !== null && task.duration !== '') {
            const numericDuration = Number(task.duration);
            if (!Number.isNaN(numericDuration) && numericDuration >= 0) {
              task.duration = numericDuration > 24 ? Math.round(numericDuration) : Math.round(numericDuration * 60);
            } else {
              delete task.duration;
            }
          } else {
            delete task.duration;
          }

          if (typeof task.notes === 'string') {
            task.notes = task.notes.trim();
            if (!task.notes) delete task.notes;
          }

          if (task.color && !category.color) {
            category.color = task.color;
          }
          delete task.color;

          task.missionCritical = Boolean(task.missionCritical);
        });
        state.tasks[dateKey] = tasks.filter(Boolean).sort(compareTasks);
        if (state.tasks[dateKey].length === 0) {
          delete state.tasks[dateKey];
        }
      });

      state.categories.sort((a, b) => a.name.localeCompare(b.name));
    }

    function saveState() {
      localStorage.setItem(storageKey, JSON.stringify(state));
    }

    function formatDateKey(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function parseDateKey(key) {
      const [year, month, day] = key.split('-').map(Number);
      return new Date(year, month - 1, day);
    }

    function formatFullDate(date) {
      return date.toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric' });
    }

    function formatTime(date) {
      return date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
    }

    function formatDuration(minutes) {
      const total = Math.max(0, Math.round(Number(minutes) || 0));
      const hours = Math.floor(total / 60);
      const mins = total % 60;
      const parts = [];
      if (hours > 0) {
        parts.push(`${hours}h`);
      }
      if (mins > 0) {
        parts.push(`${mins}m`);
      }
      return parts.length ? parts.join(' ') : '0m';
    }

    function createRollingPicker({
      pickerEl,
      displayEl,
      panelEl,
      hiddenInput,
      placeholder,
      options = [],
      defaultFocusValue = ''
    }) {
      if (!pickerEl || !displayEl || !panelEl || !hiddenInput) return null;

      const normalizedOptions = options.map(({ value, label }) => ({
        value: value == null ? '' : String(value),
        label
      }));
      const optionMap = new Map();
      let isOpen = false;

      function addOption(value, label, { custom = false } = {}) {
        const option = document.createElement('button');
        option.type = 'button';
        option.className = 'time-option';
        option.dataset.value = value;
        option.dataset.label = label;
        if (custom) option.dataset.custom = 'true';
        option.textContent = label;
        option.setAttribute('role', 'option');
        option.setAttribute('aria-selected', 'false');
        option.addEventListener('click', () => {
          setValue(value);
          close({ focus: false });
        });
        option.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            setValue(value);
            close();
          }
        });
        pickerEl.appendChild(option);
        optionMap.set(value, option);
        return option;
      }

      function updateDisplay(normalized) {
        const option = optionMap.get(normalized);
        const label = option?.dataset.label || placeholder;
        displayEl.textContent = normalized ? label : placeholder;
        displayEl.dataset.value = normalized;
      }

      function ensureOption(value, label) {
        const normalized = value == null ? '' : String(value);
        if (optionMap.has(normalized)) return optionMap.get(normalized);
        return addOption(normalized, label ?? normalized, { custom: true });
      }

      function setValue(value, { scrollIntoView = false, focusOption = false } = {}) {
        const normalized = value == null ? '' : String(value);
        if (normalized && !optionMap.has(normalized)) {
          ensureOption(normalized, normalized);
        }
        hiddenInput.value = normalized;
        let target = null;
        optionMap.forEach((option, key) => {
          const isMatch = key === normalized;
          option.classList.toggle('selected', isMatch);
          option.setAttribute('aria-selected', isMatch ? 'true' : 'false');
          if (isMatch) target = option;
        });
        updateDisplay(normalized);
        if (scrollIntoView && target) {
          target.scrollIntoView({ block: 'center' });
        }
        if (focusOption && target) {
          target.focus({ preventScroll: true });
        }
        return target;
      }

      function scrollToValue(value, { focus = false } = {}) {
        const normalized = value == null ? '' : String(value);
        const option = optionMap.get(normalized);
        if (!option) return null;
        const offset = option.offsetTop - pickerEl.clientHeight / 2 + option.offsetHeight / 2;
        pickerEl.scrollTop = Math.max(0, offset);
        if (focus) {
          option.focus({ preventScroll: true });
        }
        return option;
      }

      function scrollToDefault({ focus = false } = {}) {
        if (!defaultFocusValue || !optionMap.has(defaultFocusValue)) return null;
        return scrollToValue(defaultFocusValue, { focus });
      }

      function handlePickerKeydown(event) {
        const options = Array.from(pickerEl.querySelectorAll('.time-option'));
        if (!options.length) return;
        let index = options.indexOf(document.activeElement);
        if (index === -1) {
          index = options.findIndex((option) => option.dataset.value === (hiddenInput.value || ''));
          if (index === -1) index = 0;
        }
        if (event.key === 'ArrowDown') {
          event.preventDefault();
          index = Math.min(options.length - 1, index + 1);
          const next = options[index];
          setValue(next.dataset.value, { scrollIntoView: true, focusOption: true });
        } else if (event.key === 'ArrowUp') {
          event.preventDefault();
          index = Math.max(0, index - 1);
          const next = options[index];
          setValue(next.dataset.value, { scrollIntoView: true, focusOption: true });
        } else if (event.key === 'Home') {
          event.preventDefault();
          const next = options[0];
          setValue(next.dataset.value, { scrollIntoView: true, focusOption: true });
        } else if (event.key === 'End') {
          event.preventDefault();
          const next = options[options.length - 1];
          setValue(next.dataset.value, { scrollIntoView: true, focusOption: true });
        }
      }

      function handleOutsidePointer(event) {
        if (panelEl.contains(event.target) || event.target === displayEl) return;
        close({ focus: false });
      }

      function handleGlobalKeydown(event) {
        if (event.key === 'Escape') {
          event.preventDefault();
          close();
        }
      }

      function open({ focus = true } = {}) {
        if (isOpen) return;
        isOpen = true;
        panelEl.hidden = false;
        requestAnimationFrame(() => {
          panelEl.classList.add('open');
        });
        displayEl.setAttribute('aria-expanded', 'true');
        const currentValue = hiddenInput.value || '';
        let focusTarget = null;
        if (currentValue && optionMap.has(currentValue)) {
          focusTarget = optionMap.get(currentValue);
          focusTarget?.focus({ preventScroll: true });
          focusTarget?.scrollIntoView({ block: 'center' });
        } else {
          focusTarget = scrollToDefault({ focus: true });
          if (!focusTarget) {
            focusTarget = pickerEl.querySelector('.time-option');
            focusTarget?.focus({ preventScroll: true });
            focusTarget?.scrollIntoView({ block: 'center' });
          }
        }
        document.addEventListener('pointerdown', handleOutsidePointer, true);
        document.addEventListener('keydown', handleGlobalKeydown, true);
      }

      function close({ focus = true } = {}) {
        if (!isOpen) return;
        isOpen = false;
        panelEl.classList.remove('open');
        displayEl.setAttribute('aria-expanded', 'false');
        const finalize = () => {
          panelEl.hidden = true;
          panelEl.removeEventListener('transitionend', finalize);
        };
        panelEl.addEventListener('transitionend', finalize);
        document.removeEventListener('pointerdown', handleOutsidePointer, true);
        document.removeEventListener('keydown', handleGlobalKeydown, true);
        if (focus) {
          displayEl.focus();
        }
      }

      function toggle() {
        if (isOpen) {
          close({ focus: false });
        } else {
          open();
        }
      }

      function rebuild() {
        pickerEl.innerHTML = '';
        optionMap.clear();
        normalizedOptions.forEach(({ value, label }) => addOption(value, label));
        const initialValue = hiddenInput.value || '';
        if (initialValue && !optionMap.has(initialValue)) {
          addOption(initialValue, initialValue, { custom: true });
        }
        setValue(initialValue, { scrollIntoView: false, focusOption: false });
      }

      pickerEl.addEventListener('keydown', handlePickerKeydown);
      displayEl.addEventListener('click', (event) => {
        event.preventDefault();
        toggle();
      });
      displayEl.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ' || event.key === 'ArrowDown') {
          event.preventDefault();
          open();
        } else if (event.key === 'Escape') {
          event.preventDefault();
          close();
        }
      });

      rebuild();

      return {
        setValue,
        ensureOption,
        scrollToDefault,
        scrollToValue,
        open,
        close,
        rebuild
      };
    }

    function compareTasks(a, b) {
      const timeA = a.start || '';
      const timeB = b.start || '';
      const hasTimeA = Boolean(timeA);
      const hasTimeB = Boolean(timeB);
      if (!hasTimeA && hasTimeB) return -1;
      if (hasTimeA && !hasTimeB) return 1;
      if (hasTimeA && hasTimeB && timeA !== timeB) {
        return timeA.localeCompare(timeB);
      }
      if (a.missionCritical && !b.missionCritical) return -1;
      if (!a.missionCritical && b.missionCritical) return 1;
      const durationA = Number(a.duration) || 0;
      const durationB = Number(b.duration) || 0;
      if (durationA !== durationB) return durationB - durationA;
      return a.title.localeCompare(b.title);
    }

    function hexToRgba(hex, alpha) {
      if (!hex || typeof hex !== 'string') return `rgba(255,255,255,${alpha})`;
      const stripped = hex.replace('#', '');
      const bigint = parseInt(stripped.length === 3
        ? stripped.split('').map((c) => c + c).join('')
        : stripped, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }


    const calendarGridEl = document.getElementById('calendar-grid');
    const yearViewEl = document.getElementById('year-view');
    const yearLabels = document.querySelectorAll('[data-year-label]');
    const yearNavButtons = document.querySelectorAll('[data-year-nav]');
    const currentDateEl = document.querySelector('.current-date');
    const currentTimeEl = document.querySelector('.current-time');
    const taskModalBackdrop = document.getElementById('task-modal');
    const taskForm = document.getElementById('task-form');
    const taskModalTitle = document.getElementById('task-modal-title');
    const taskDeleteBtn = document.getElementById('task-delete');
    const taskCancelBtn = document.getElementById('task-cancel');
    const taskCategorySelect = document.getElementById('task-category');
    const newCategoryNameField = document.getElementById('new-category-name-field');
    const newCategoryNameInput = document.getElementById('new-category-name');
    const newCategoryColorField = document.getElementById('new-category-color-field');
    const newCategoryColorInput = document.getElementById('new-category-color');
    const categoryColorOptions = document.getElementById('category-color-options');
    const missionCriticalInput = document.getElementById('task-mission-critical');
    const taskTitleInput = document.getElementById('task-title');
    const taskStartPicker = document.getElementById('task-start-picker');
    const taskStartDisplay = document.getElementById('task-start-display');
    const taskStartPanel = document.getElementById('task-start-panel');
    const taskStartInput = document.getElementById('task-start');
    const taskDurationPicker = document.getElementById('task-duration-picker');
    const taskDurationDisplay = document.getElementById('task-duration-display');
    const taskDurationPanel = document.getElementById('task-duration-panel');
    const taskDurationInput = document.getElementById('task-duration');
    const taskNotesInput = document.getElementById('task-notes');
    const categoryPreviewEl = document.getElementById('category-preview');
    const deleteCategoryBtn = document.getElementById('delete-category');
    if (deleteCategoryBtn) {
      deleteCategoryBtn.disabled = true;
      deleteCategoryBtn.setAttribute('aria-disabled', 'true');
    }

    const focusModalBackdrop = document.getElementById('focus-modal');
    const focusForm = document.getElementById('focus-form');
    const focusModalTitle = document.getElementById('focus-modal-title');
    const focusDeleteBtn = document.getElementById('focus-delete');
    const focusCancelBtn = document.getElementById('focus-cancel');

    const miniTooltip = document.createElement('div');
    miniTooltip.className = 'mini-tooltip';
    document.body.appendChild(miniTooltip);
    let miniTooltipVisible = false;

    if (yearViewEl) {
      yearViewEl.addEventListener('scroll', hideMiniTooltip);
    }
    window.addEventListener('scroll', hideMiniTooltip, true);
    window.addEventListener('resize', hideMiniTooltip);

    function hideMiniTooltip() {
      if (!miniTooltipVisible) return;
      miniTooltip.classList.remove('visible');
      miniTooltipVisible = false;
    }

    function positionMiniTooltip(x, y) {
      const safeX = Math.max(16, Math.min(window.innerWidth - 16, x));
      const safeY = Math.max(16, y - 18);
      miniTooltip.style.left = `${safeX}px`;
      miniTooltip.style.top = `${safeY}px`;
    }

    function updateMiniTooltipPosition(x, y) {
      if (!miniTooltipVisible) return;
      positionMiniTooltip(x, y);
    }

    function showMiniTooltip(text, x, y) {
      if (!text) {
        hideMiniTooltip();
        return;
      }
      miniTooltip.textContent = text;
      positionMiniTooltip(x, y);
      miniTooltip.classList.add('visible');
      miniTooltipVisible = true;
    }

    const startPickerController = createRollingPicker({
      pickerEl: taskStartPicker,
      displayEl: taskStartDisplay,
      panelEl: taskStartPanel,
      hiddenInput: taskStartInput,
      placeholder: 'No start time',
      options: [{ value: '', label: 'No start time' }, ...startTimeOptions.map((time) => ({ value: time, label: time }))],
      defaultFocusValue: '12:00'
    });

    const durationPickerController = createRollingPicker({
      pickerEl: taskDurationPicker,
      displayEl: taskDurationDisplay,
      panelEl: taskDurationPanel,
      hiddenInput: taskDurationInput,
      placeholder: 'No duration',
      options: [{ value: '', label: 'No duration' }, ...durationOptions.map(({ value, label }) => ({ value: String(value), label }))],
      defaultFocusValue: '60'
    });

    renderCategoryColorOptions();
    selectCategoryColor(categoryPalette[0]);

    let state = loadState();
    ensureGeneralCategoryExists();
    let viewDate = new Date();
    viewDate = new Date(viewDate.getFullYear(), viewDate.getMonth(), 1);

    let editingTask = null;
    let editingDate = null;
    let editingFocusId = null;
    let draggedTask = null;
    let focusSelection = null;
    let focusSelectionPointerId = null;
    let initialScrollCompleted = false;
    let initialMiniScrollCompleted = false;
    const dayHighlightTimers = new Map();

    function detachFocusPointerListeners() {
      window.removeEventListener('pointerup', handleFocusPointerUp);
      window.removeEventListener('pointercancel', handleFocusPointerCancel);
    }

    function clearFocusSelectionHighlights() {
      if (calendarGridEl) {
        calendarGridEl.querySelectorAll('.day.focus-range').forEach((cell) => {
          cell.classList.remove('focus-range');
        });
      }
      if (yearViewEl) {
        yearViewEl.querySelectorAll('.mini-day.focus-range').forEach((cell) => {
          cell.classList.remove('focus-range');
        });
      }
    }

    function updateFocusSelectionHighlight() {
      clearFocusSelectionHighlights();
      if (!focusSelection) return;
      const { anchor, current } = focusSelection;
      const [startKey, endKey] = anchor <= current ? [anchor, current] : [current, anchor];
      const startDate = parseDateKey(startKey);
      const endDate = parseDateKey(endKey);
      const cursor = new Date(startDate);
      while (cursor <= endDate) {
        const key = formatDateKey(cursor);
        const cell = calendarGridEl?.querySelector(`.day[data-date="${key}"]`);
        if (cell) {
          cell.classList.add('focus-range');
        }
        const miniCell = yearViewEl?.querySelector(`.mini-day[data-date="${key}"]`);
        if (miniCell) {
          miniCell.classList.add('focus-range');
        }
        cursor.setDate(cursor.getDate() + 1);
      }
    }

    function clearFocusSelection() {
      clearFocusSelectionHighlights();
      focusSelection = null;
      focusSelectionPointerId = null;
      detachFocusPointerListeners();
    }

    function finalizeFocusSelection() {
      if (!focusSelection) return;
      const { anchor, current } = focusSelection;
      const [startKey, endKey] = anchor <= current ? [anchor, current] : [current, anchor];
      clearFocusSelection();
      openFocusModal(null, { start: startKey, end: endKey });
    }

    function handleFocusPointerUp(event) {
      if (!focusSelection) {
        detachFocusPointerListeners();
        return;
      }
      if (focusSelectionPointerId != null && event.pointerId !== focusSelectionPointerId) {
        return;
      }
      finalizeFocusSelection();
    }

    function handleFocusPointerCancel() {
      clearFocusSelection();
    }

    function startFocusSelection(dateKey, pointerId) {
      clearFocusSelection();
      focusSelection = { anchor: dateKey, current: dateKey };
      focusSelectionPointerId = pointerId;
      updateFocusSelectionHighlight();
      window.addEventListener('pointerup', handleFocusPointerUp);
      window.addEventListener('pointercancel', handleFocusPointerCancel);
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && focusSelection) {
        clearFocusSelection();
      }
    });

    function clearDragState() {
      draggedTask = null;
      document.querySelectorAll('.drag-over').forEach((day) => day.classList.remove('drag-over'));
      document.querySelectorAll('.timeline-task.is-dragging').forEach((card) => card.classList.remove('is-dragging'));
    }

    function renderCategoryColorOptions() {
      if (!categoryColorOptions) return;
      categoryColorOptions.innerHTML = '';
      categoryPalette.forEach((color) => {
        const swatch = document.createElement('button');
        swatch.type = 'button';
        swatch.className = 'color-swatch';
        swatch.style.setProperty('--swatch-color', color);
        swatch.dataset.color = color;
        swatch.setAttribute('aria-pressed', 'false');
        swatch.title = color;
        swatch.addEventListener('click', () => selectCategoryColor(color));
        swatch.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            selectCategoryColor(color);
          }
        });
        categoryColorOptions.appendChild(swatch);
      });
    }

    function selectCategoryColor(color) {
      if (!newCategoryColorInput) return;
      newCategoryColorInput.value = color;
      if (!categoryColorOptions) return;
      categoryColorOptions.querySelectorAll('.color-swatch').forEach((swatch) => {
        swatch.setAttribute('aria-pressed', swatch.dataset.color === color ? 'true' : 'false');
      });
    }

    function toggleNewCategoryFields(show) {
      newCategoryNameField.classList.toggle('hidden', !show);
      newCategoryColorField.classList.toggle('hidden', !show);
      if (show) {
        if (!newCategoryColorInput.value) {
          selectCategoryColor(categoryPalette[0]);
        } else {
          selectCategoryColor(newCategoryColorInput.value);
        }
        newCategoryNameInput.focus();
      } else {
        newCategoryNameInput.value = '';
        newCategoryColorInput.value = '';
        categoryColorOptions.querySelectorAll('.color-swatch').forEach((swatch) => {
          swatch.setAttribute('aria-pressed', 'false');
        });
      }
    }

    function getCategoryByName(name) {
      if (!name || !Array.isArray(state.categories)) return null;
      const target = name.toLowerCase();
      return state.categories.find((category) => category.name.toLowerCase() === target) || null;
    }

    function ensureGeneralCategoryExists() {
      let general = getCategoryByName('General');
      if (!general) {
        general = { id: state.nextCategoryId++, name: 'General', color: '#6A5ACD' };
        state.categories.push(general);
      }
      return general;
    }

    function getSortedCategories() {
      ensureGeneralCategoryExists();
      return state.categories
        .slice()
        .sort((a, b) => {
          if (a.name === 'General') return -1;
          if (b.name === 'General') return 1;
          return a.name.localeCompare(b.name);
        });
    }

    function renderCategoryPreview(categories, selectedValue) {
      if (!categoryPreviewEl) return;
      categoryPreviewEl.innerHTML = '';
      const showPreview = selectedValue && selectedValue !== '__new__';
      categoryPreviewEl.classList.toggle('hidden', !showPreview);
      if (!showPreview) return;

      categories.forEach((category) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'category-chip';
        chip.dataset.category = category.name;
        chip.setAttribute('aria-pressed', category.name === selectedValue ? 'true' : 'false');

        const dot = document.createElement('span');
        dot.className = 'category-chip-dot';
        dot.style.background = category.color;
        chip.appendChild(dot);
        chip.append(category.name);

        chip.addEventListener('click', () => {
          taskCategorySelect.value = category.name;
          updateCategoryPreviewSelection(category.name);
          toggleNewCategoryFields(false);
          updateDeleteCategoryButtonState(category.name);
        });

        chip.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            taskCategorySelect.value = category.name;
            updateCategoryPreviewSelection(category.name);
            toggleNewCategoryFields(false);
            updateDeleteCategoryButtonState(category.name);
          }
        });

        categoryPreviewEl.appendChild(chip);
      });
    }

    function updateCategoryPreviewSelection(value) {
      if (!categoryPreviewEl) return;
      categoryPreviewEl.querySelectorAll('.category-chip').forEach((chip) => {
        chip.setAttribute('aria-pressed', chip.dataset.category === value ? 'true' : 'false');
      });
    }

    function updateDeleteCategoryButtonState(selectedValue) {
      if (!deleteCategoryBtn) return;
      const disabled = !selectedValue || selectedValue === '__new__' || selectedValue.toLowerCase() === 'general';
      deleteCategoryBtn.disabled = disabled;
      deleteCategoryBtn.setAttribute('aria-disabled', String(disabled));
    }

    function populateCategorySelect(selectedName, forceNew = false) {
      const sorted = getSortedCategories();

      taskCategorySelect.innerHTML = '';
      sorted.forEach((category) => {
        const option = document.createElement('option');
        option.value = category.name;
        option.textContent = category.name;
        taskCategorySelect.appendChild(option);
      });

      const newOption = document.createElement('option');
      newOption.value = '__new__';
      newOption.textContent = 'Add new category…';
      taskCategorySelect.appendChild(newOption);

      let nextValue;
      if (forceNew) {
        nextValue = '__new__';
      } else if (selectedName) {
        const match = sorted.find((category) => category.name === selectedName);
        nextValue = match ? match.name : (sorted[0]?.name || '__new__');
      } else {
        nextValue = sorted[0] ? sorted[0].name : '__new__';
      }

      taskCategorySelect.value = nextValue;
      toggleNewCategoryFields(nextValue === '__new__');
      renderCategoryPreview(sorted, nextValue);
      updateDeleteCategoryButtonState(nextValue);
    }

    function openTaskModal(dateKey, task) {
      editingDate = dateKey;
      editingTask = task ? { ...task } : null;
      taskModalBackdrop.classList.add('open');
      taskModalTitle.textContent = task ? 'Update task' : 'Plan a task';
      taskDeleteBtn.style.display = task ? 'inline-flex' : 'none';

      taskForm.reset();
      missionCriticalInput.checked = Boolean(task?.missionCritical);
      taskTitleInput.value = task?.title || '';
      const startValue = task?.start || '';
      if (startPickerController) {
        if (startValue) {
          startPickerController.ensureOption(startValue, startValue);
        }
        startPickerController.setValue(startValue, { scrollIntoView: Boolean(startValue) });
        if (!startValue) {
          startPickerController.scrollToDefault({ focus: false });
        }
      } else if (taskStartInput) {
        taskStartInput.value = startValue;
      }

      const durationValue = typeof task?.duration === 'number' && task.duration > 0 ? task.duration : '';
      if (durationPickerController) {
        if (durationValue !== '') {
          durationPickerController.ensureOption(durationValue, formatDuration(durationValue));
        }
        durationPickerController.setValue(durationValue === '' ? '' : durationValue, {
          scrollIntoView: durationValue !== ''
        });
      } else if (taskDurationInput) {
        taskDurationInput.value = durationValue === '' ? '' : String(durationValue);
      }
      taskNotesInput.value = task?.notes || '';
      newCategoryNameInput.value = '';
      newCategoryColorInput.value = '';
      populateCategorySelect(task?.category || null);

        if (task && taskCategorySelect.value === '__new__') {
          newCategoryNameInput.value = task.category || '';
          const fallbackColor = getCategoryByName(task.category)?.color || pickCategoryColor(state);
          newCategoryColorInput.value = fallbackColor;
          toggleNewCategoryFields(true);
          selectCategoryColor(fallbackColor);
        }
    }

    function closeTaskModal() {
      taskModalBackdrop.classList.remove('open');
      editingTask = null;
      editingDate = null;
      draggedTask = null;
      missionCriticalInput.checked = false;
      toggleNewCategoryFields(false);
      startPickerController?.close({ focus: false });
      durationPickerController?.close({ focus: false });
    }

    function openFocusModal(project, options = {}) {
      editingFocusId = project ? project.id : null;
      focusModalBackdrop.classList.add('open');
      focusModalTitle.textContent = project ? 'Update focus block' : 'New focus block';
      focusDeleteBtn.style.display = project ? 'inline-flex' : 'none';

      focusForm.reset();
      const colorField = document.getElementById('focus-color');
      const nameField = document.getElementById('focus-name');
      const startField = document.getElementById('focus-start');
      const endField = document.getElementById('focus-end');

      colorField.value = project?.color || options.color || '#ff6f91';
      if (project) {
        nameField.value = project.name;
        startField.value = project.start;
        endField.value = project.end;
      } else {
        if (options.name) nameField.value = options.name;
        const defaultDate = formatDateKey(new Date());
        const startValue = options.start || defaultDate;
        const endValue = options.end || options.start || defaultDate;
        startField.value = startValue;
        endField.value = endValue;
      }
    }

    function closeFocusModal() {
      focusModalBackdrop.classList.remove('open');
      editingFocusId = null;
    }

    function ensureTasks(dateKey) {
      if (!state.tasks[dateKey]) state.tasks[dateKey] = [];
      return state.tasks[dateKey];
    }

    function removeEmptyTaskLists(dateKey) {
      if (state.tasks[dateKey] && state.tasks[dateKey].length === 0) {
        delete state.tasks[dateKey];
      }
    }

    function createWeekdayRow() {
      const row = document.createElement('div');
      row.className = 'weekday-row';
      const labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      labels.forEach((label, index) => {
        const span = document.createElement('span');
        span.textContent = label;
        if (index >= 5) {
          span.classList.add('weekend');
        }
        row.appendChild(span);
      });
      return row;
    }

    function computeCalendarBounds() {
      const anchorYear = viewDate.getFullYear();
      const start = new Date(anchorYear, 0, 1);
      const end = new Date(anchorYear, 11, 31);
      return { start, end };
    }

    function buildMonthSequence() {
      const { start, end } = computeCalendarBounds();
      const cursor = new Date(start);
      cursor.setDate(1);
      const months = [];
      while (cursor <= end) {
        months.push({ year: cursor.getFullYear(), month: cursor.getMonth() });
        cursor.setMonth(cursor.getMonth() + 1);
      }
      return months;
    }

    function updateYearLabels() {
      const year = viewDate.getFullYear();
      yearLabels.forEach((label) => {
        label.textContent = year;
      });
    }

    function createMiniWeekdayRow() {
      const row = document.createElement('div');
      row.className = 'mini-weekday-row';
      const labels = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];
      labels.forEach((label) => {
        const span = document.createElement('span');
        span.textContent = label;
        row.appendChild(span);
      });
      return row;
    }

    function renderYearOverview() {
      if (!yearViewEl) return;
      yearViewEl.innerHTML = '';
      hideMiniTooltip();
      const months = buildMonthSequence();
      const realTodayKey = formatDateKey(new Date());

      months.forEach(({ year, month }) => {
        const container = document.createElement('div');
        container.className = 'mini-month';
        container.dataset.year = String(year);
        container.dataset.month = String(month);

        const header = document.createElement('div');
        header.className = 'mini-month-header';
        const monthLabel = document.createElement('span');
        const labelDate = new Date(year, month, 1);
        monthLabel.textContent = labelDate.toLocaleDateString(undefined, { month: 'long' });
        const yearLabel = document.createElement('span');
        yearLabel.className = 'mini-year';
        yearLabel.textContent = labelDate.toLocaleDateString(undefined, { year: 'numeric' });
        header.appendChild(monthLabel);
        header.appendChild(yearLabel);
        container.appendChild(header);

        container.appendChild(createMiniWeekdayRow());

        const grid = document.createElement('div');
        grid.className = 'mini-grid';
        container.appendChild(grid);

        const firstDay = new Date(year, month, 1);
        const startWeekday = (firstDay.getDay() + 6) % 7;
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const totalCells = Math.ceil((startWeekday + daysInMonth) / 7) * 7;

        for (let i = 0; i < totalCells; i++) {
          const cell = document.createElement('div');
          cell.className = 'mini-day';

          const dayNumber = i - startWeekday + 1;
          if (dayNumber < 1 || dayNumber > daysInMonth) {
            cell.classList.add('empty');
            cell.addEventListener('click', (event) => {
              if (event.detail > 1) return;
              event.preventDefault();
              scrollMainCalendarToMonth(year, month, { smooth: true });
              hideMiniTooltip();
            });
            cell.addEventListener('dblclick', (event) => {
              event.preventDefault();
              scrollMainCalendarToMonth(year, month, { smooth: false });
              hideMiniTooltip();
            });
            cell.addEventListener('mouseleave', hideMiniTooltip);
            grid.appendChild(cell);
            continue;
          }

          const date = new Date(year, month, dayNumber);
          const dateKey = formatDateKey(date);
          cell.dataset.date = dateKey;
          const weekday = date.getDay();
          if (weekday === 0 || weekday === 6) {
            cell.classList.add('weekend');
          }
          if (dateKey === realTodayKey) {
            cell.classList.add('today');
          }

          const number = document.createElement('span');
          number.className = 'mini-day-number';
          number.textContent = dayNumber;
          cell.appendChild(number);

          const activeProjects = state.projects.filter((project) => project.start <= dateKey && project.end >= dateKey);
          if (activeProjects.length) {
            const stack = document.createElement('div');
            stack.className = 'mini-focus-stack';
            activeProjects.forEach((project, projectIndex) => {
              const block = document.createElement('button');
              block.type = 'button';
              block.className = 'mini-focus-block';
              block.style.setProperty('--mini-focus-strong', hexToRgba(project.color, 0.45));
              block.style.setProperty('--mini-focus-soft', hexToRgba(project.color, 0.12));
              block.style.setProperty('--mini-focus-border', hexToRgba(project.color, 0.6));
              block.title = project.name;
              block.setAttribute('aria-label', project.name);
              block.dataset.projectIndex = String(projectIndex);
              block.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                  event.preventDefault();
                  event.stopPropagation();
                  hideMiniTooltip();
                  openFocusModal(project);
                }
              });
              stack.appendChild(block);
            });
            cell.appendChild(stack);
          }

          const focusTooltipText = activeProjects.map((project) => project.name).join('\n');

          cell.addEventListener('mouseenter', (event) => {
            if (cell.classList.contains('empty') || !focusTooltipText) {
              hideMiniTooltip();
              return;
            }
            showMiniTooltip(focusTooltipText, event.clientX, event.clientY);
          });

          cell.addEventListener('mousemove', (event) => {
            updateMiniTooltipPosition(event.clientX, event.clientY);
          });

          cell.addEventListener('mouseleave', hideMiniTooltip);

          cell.addEventListener('click', (event) => {
            if (cell.classList.contains('empty')) return;
            if (event.detail > 1) return;
            event.preventDefault();
            scrollMainCalendarToMonth(year, month, { smooth: true });
            hideMiniTooltip();
            flashMainCalendarDay(dateKey, { delay: 420 });
          });

          cell.addEventListener('dblclick', (event) => {
            if (cell.classList.contains('empty')) return;
            event.preventDefault();
            scrollMainCalendarToMonth(year, month, { smooth: false });
            hideMiniTooltip();
            flashMainCalendarDay(dateKey);
            let projectToEdit = activeProjects[0] || null;
            const blockTarget = event.target.closest('.mini-focus-block');
            if (blockTarget) {
              const index = Number(blockTarget.dataset.projectIndex);
              if (!Number.isNaN(index) && activeProjects[index]) {
                projectToEdit = activeProjects[index];
              }
            }
            if (projectToEdit) {
              openFocusModal(projectToEdit);
            } else {
              openFocusModal(null, { start: dateKey, end: dateKey });
            }
          });

          cell.addEventListener('pointerdown', (event) => {
            if (event.button !== 0 || !event.shiftKey) return;
            event.preventDefault();
            startFocusSelection(dateKey, event.pointerId);
          });

          cell.addEventListener('pointerenter', () => {
            if (!focusSelection) return;
            focusSelection.current = dateKey;
            updateFocusSelectionHighlight();
          });

          grid.appendChild(cell);
        }

        yearViewEl.appendChild(container);
      });

      if (!initialMiniScrollCompleted) {
        scrollMiniViewToMonth(viewDate, { smooth: false });
        initialMiniScrollCompleted = true;
      }
    }

    function getTaskTimeRange(task) {
      if (!task || !task.start) return '';
      const endTime = task.duration ? computeEndTime(task.start, task.duration) : null;
      return endTime ? `${task.start} - ${endTime}` : task.start;
    }


    function setupFlyoutHover(cell, flyout) {
      if (!cell || !flyout) return;
      let hideTimeout;

      const show = () => {
        clearTimeout(hideTimeout);
        cell.classList.add('show-flyout');
      };

      const hide = () => {
        cell.classList.remove('show-flyout');
      };

      const scheduleHide = (event) => {
        const related = event?.relatedTarget;
        if (related && (cell.contains(related) || flyout.contains(related))) {
          return;
        }
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(hide, 140);
      };

      cell.addEventListener('mouseenter', show);
      cell.addEventListener('mouseleave', scheduleHide);
      flyout.addEventListener('mouseenter', show);
      flyout.addEventListener('mouseleave', scheduleHide);
    }

    function scrollMainCalendarToMonth(year, month, { smooth = true } = {}) {
      if (!calendarGridEl) return;
      const selector = `.month-block[data-year="${year}"][data-month="${month}"]`;
      const target = calendarGridEl.querySelector(selector);
      if (target) {
        initialScrollCompleted = true;
        target.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'start' });
      }
    }

    function flashMainCalendarDay(dateKey, { delay = 0 } = {}) {
      if (!calendarGridEl || !dateKey) return;
      const trigger = () => {
        const dayEl = calendarGridEl.querySelector(`.day[data-date="${dateKey}"]`);
        if (!dayEl) return;
        dayEl.classList.add('highlight-pulse');
        const existing = dayHighlightTimers.get(dateKey);
        if (existing) {
          clearTimeout(existing);
        }
        const timeout = setTimeout(() => {
          dayEl.classList.remove('highlight-pulse');
          dayHighlightTimers.delete(dateKey);
        }, 1950);
        dayHighlightTimers.set(dateKey, timeout);
      };
      if (delay > 0) {
        setTimeout(trigger, delay);
      } else {
        trigger();
      }
    }

    function scrollMiniViewToMonth(date, { smooth = true } = {}) {
      if (!yearViewEl || !date) return;
      const selector = `.mini-month[data-year="${date.getFullYear()}"][data-month="${date.getMonth()}"]`;
      const target = yearViewEl.querySelector(selector);
      if (target) {
        target.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'start' });
      }
    }

    function scrollToToday({ smooth = true } = {}) {
      if (!calendarGridEl) return;
      const todayCell = calendarGridEl.querySelector('.day.today');
      if (!todayCell) return;
      todayCell.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'center' });
    }

    function renderCalendar() {
      clearDragState();
      if (!calendarGridEl) return;

      calendarGridEl.innerHTML = '';
      const months = buildMonthSequence();
      const realTodayKey = formatDateKey(new Date());

      months.forEach(({ year, month }) => {
        const monthBlock = document.createElement('div');
        monthBlock.className = 'month-block';
        monthBlock.dataset.year = String(year);
        monthBlock.dataset.month = String(month);

        const labelDate = new Date(year, month, 1);
        const labelText = labelDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });

        const divider = document.createElement('div');
        divider.className = 'month-divider';
        const overlayLabel = document.createElement('span');
        overlayLabel.className = 'month-label';
        overlayLabel.textContent = labelText;
        divider.appendChild(overlayLabel);

        monthBlock.appendChild(divider);
        monthBlock.appendChild(createWeekdayRow());

        const monthGrid = document.createElement('div');
        monthGrid.className = 'calendar-grid';
        monthBlock.appendChild(monthGrid);

        const firstDay = new Date(year, month, 1);
        const startWeekday = (firstDay.getDay() + 6) % 7;
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const totalCells = Math.ceil((startWeekday + daysInMonth) / 7) * 7;

        for (let i = 0; i < totalCells; i++) {
          const cell = document.createElement('div');
          cell.className = 'day';

          const dayNumber = i - startWeekday + 1;
          if (dayNumber < 1 || dayNumber > daysInMonth) {
            cell.classList.add('empty');
            monthGrid.appendChild(cell);
            continue;
          }

          const date = new Date(year, month, dayNumber);
          const dateKey = formatDateKey(date);
          cell.dataset.date = dateKey;

          const weekday = date.getDay();
          if (weekday === 0 || weekday === 6) {
            cell.classList.add('weekend');
          }

          if (realTodayKey === dateKey) {
            cell.classList.add('today');
          }

          cell.addEventListener('pointerdown', (event) => {
            if (event.button !== 0 || !event.shiftKey) return;
            if (event.target.closest('.timeline-task') || event.target.closest('.task-flyout') || event.target.closest('.add-task-btn') || event.target.closest('.focus-badge')) {
              return;
            }
            event.preventDefault();
            startFocusSelection(dateKey, event.pointerId);
          });

          cell.addEventListener('pointerenter', () => {
            if (!focusSelection) return;
            focusSelection.current = dateKey;
            updateFocusSelectionHighlight();
          });

          cell.addEventListener('dragenter', (event) => {
            event.preventDefault();
            cell.classList.add('drag-over');
          });

          cell.addEventListener('dragover', (event) => {
            event.preventDefault();
            cell.classList.add('drag-over');
            event.dataTransfer.dropEffect = 'move';
          });

          cell.addEventListener('dragleave', () => {
            cell.classList.remove('drag-over');
          });

          cell.addEventListener('drop', () => {
            cell.classList.remove('drag-over');
            if (!draggedTask) {
              clearDragState();
              return;
            }
            moveTaskToDate(draggedTask, dateKey);
            clearDragState();
          });

          const header = document.createElement('div');
          header.className = 'day-header';
          const numberEl = document.createElement('div');
          numberEl.className = 'day-number';
          numberEl.textContent = dayNumber;
          header.appendChild(numberEl);

          const addBtn = document.createElement('button');
          addBtn.className = 'add-task-btn';
          addBtn.type = 'button';
          addBtn.textContent = '+';
          addBtn.title = 'Add task';
          addBtn.addEventListener('click', () => openTaskModal(dateKey));
          header.appendChild(addBtn);

          cell.appendChild(header);

          const activeProjects = state.projects.filter((project) => project.start <= dateKey && project.end >= dateKey);
          const focusTooltipText = activeProjects.map((project) => project.name).join('\n');

          const overlayStack = document.createElement('div');
          overlayStack.className = 'focus-overlay-stack';
          const focusBadges = document.createElement('div');
          focusBadges.className = 'focus-badges';
          activeProjects.forEach((project) => {
            const overlay = document.createElement('div');
            overlay.className = 'focus-overlay';
            overlay.style.background = hexToRgba(project.color, 0.18);
            overlayStack.appendChild(overlay);

            const badge = document.createElement('button');
            badge.type = 'button';
            badge.className = 'focus-badge';
            const dot = document.createElement('span');
            dot.className = 'focus-badge-dot';
            dot.style.background = project.color;
            badge.appendChild(dot);
            const label = document.createElement('span');
            label.textContent = project.name;
            badge.appendChild(label);
            badge.addEventListener('click', (event) => {
              event.stopPropagation();
              hideMiniTooltip();
              openFocusModal(project);
            });
            badge.addEventListener('keydown', (event) => {
              if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                hideMiniTooltip();
                openFocusModal(project);
              }
            });
            focusBadges.appendChild(badge);
          });

          if (activeProjects.length > 0) {
            focusBadges.classList.add('active');
          }

          cell.appendChild(overlayStack);

          if (focusTooltipText) {
            cell.addEventListener('mouseenter', (event) => {
              showMiniTooltip(focusTooltipText, event.clientX, event.clientY);
            });
            cell.addEventListener('mousemove', (event) => {
              updateMiniTooltipPosition(event.clientX, event.clientY);
            });
          }

          cell.addEventListener('mouseleave', hideMiniTooltip);

          const tasks = (state.tasks[dateKey] || []).slice().sort(compareTasks);
          const timelineWrapper = document.createElement('div');
          timelineWrapper.className = 'task-timeline';

          if (activeProjects.length > 0) {
            timelineWrapper.appendChild(focusBadges);
          }

          const timelineScroller = document.createElement('div');
          timelineScroller.className = 'timeline-scroller';
          const timelineContent = document.createElement('div');
          timelineContent.className = 'timeline-content';
          timelineScroller.appendChild(timelineContent);
          timelineWrapper.appendChild(timelineScroller);

          const hourMarkers = document.createDocumentFragment();
          for (let hour = 0; hour <= 24; hour++) {
            const marker = document.createElement('div');
            marker.className = 'timeline-hour-marker';
            marker.style.top = `${hour * 60 * TIMELINE_MINUTE_HEIGHT}px`;
            if (hour < 24) {
              const label = document.createElement('span');
              label.textContent = formatHourLabel(hour);
              marker.appendChild(label);
            }
            hourMarkers.appendChild(marker);
          }
          timelineContent.appendChild(hourMarkers);

          if (tasks.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'timeline-empty';
            empty.textContent = 'No tasks scheduled';
            timelineContent.appendChild(empty);
          }

          let unscheduledIndex = 0;

          tasks.forEach((task) => {
            const taskBlock = document.createElement('div');
            taskBlock.className = 'timeline-task';
            taskBlock.draggable = true;
            taskBlock.dataset.taskId = task.id;
            taskBlock.tabIndex = 0;

            const category = getCategoryByName(task.category) || ensureGeneralCategoryExists();
            const taskColor = category?.color || '#6A5ACD';
            const tintStrong = hexToRgba(taskColor, 0.36);
            const tintSoft = hexToRgba(taskColor, 0.12);
            const outlineColor = hexToRgba(taskColor, 0.55);
            taskBlock.style.setProperty('--task-color-strong', tintStrong);
            taskBlock.style.setProperty('--task-color-soft', tintSoft);
            taskBlock.style.setProperty('--task-outline', outlineColor);
            taskBlock.style.setProperty('--task-pill', taskColor);

            const rawDuration = Math.round(Number(task.duration) || 0);
            const normalizedDuration = rawDuration > 0 ? rawDuration : 30;
            const clampedDuration = Math.min(Math.max(normalizedDuration, 1), MINUTES_IN_DAY);
            taskBlock.dataset.duration = String(clampedDuration);

            const startMinutes = parseTimeToMinutes(task.start);
            const maxStart = Math.max(0, MINUTES_IN_DAY - clampedDuration);
            if (startMinutes != null) {
              const topMinutes = Math.min(startMinutes, maxStart);
              taskBlock.style.top = `${topMinutes * TIMELINE_MINUTE_HEIGHT}px`;
            } else {
              const fallbackMinutes = Math.min(unscheduledIndex * 45, maxStart);
              taskBlock.style.top = `${fallbackMinutes * TIMELINE_MINUTE_HEIGHT}px`;
              unscheduledIndex += 1;
            }
            taskBlock.style.height = `${clampedDuration * TIMELINE_MINUTE_HEIGHT}px`;

            if (task.missionCritical) {
              taskBlock.classList.add('mission-critical');
            }

            const header = document.createElement('div');
            header.className = 'timeline-task-header';
            const nameEl = document.createElement('span');
            nameEl.className = 'timeline-task-name';
            nameEl.textContent = task.title;
            header.appendChild(nameEl);

            const timeRange = getTaskTimeRange(task) || task.start || 'No time set';
            const timeEl = document.createElement('span');
            timeEl.className = 'timeline-task-time';
            timeEl.textContent = timeRange;
            header.appendChild(timeEl);
            taskBlock.appendChild(header);

            const details = document.createElement('div');
            details.className = 'timeline-task-details';
            const detailRow = document.createElement('div');
            detailRow.className = 'timeline-detail-row';

            if (category) {
              const categoryDetail = document.createElement('span');
              categoryDetail.className = 'timeline-detail';
              categoryDetail.textContent = category.name;
              detailRow.appendChild(categoryDetail);
            }

            if (rawDuration > 0) {
              const durationDetail = document.createElement('span');
              durationDetail.className = 'timeline-detail';
              durationDetail.textContent = `Duration ${formatDuration(rawDuration)}`;
              detailRow.appendChild(durationDetail);
            }

            if (task.missionCritical) {
              const missionDetail = document.createElement('span');
              missionDetail.className = 'timeline-detail mission-critical';
              missionDetail.textContent = 'Mission critical';
              detailRow.appendChild(missionDetail);
            }

            if (detailRow.children.length) {
              details.appendChild(detailRow);
            }

            if (task.notes) {
              const firstLine = task.notes.split(/\r?\n/)[0].trim();
              if (firstLine) {
                const noteLine = document.createElement('div');
                noteLine.className = 'timeline-note';
                noteLine.textContent = firstLine;
                details.appendChild(noteLine);
              }
            }

            if (details.children.length) {
              taskBlock.appendChild(details);
            }

            taskBlock.addEventListener('dragstart', (event) => {
              const rect = taskBlock.getBoundingClientRect();
              const offset = event.clientY != null ? event.clientY - rect.top : 0;
              draggedTask = {
                id: task.id,
                fromDate: dateKey,
                offsetMinutes: offset / TIMELINE_MINUTE_HEIGHT,
                duration: clampedDuration
              };
              if (event.dataTransfer) {
                event.dataTransfer.effectAllowed = 'move';
                event.dataTransfer.setData('text/plain', String(task.id));
                try {
                  event.dataTransfer.setDragImage(taskBlock, event.clientX - rect.left, offset);
                } catch (err) {
                  // Ignore drag image issues in unsupported browsers.
                }
              }
              taskBlock.classList.add('is-dragging');
            });

            taskBlock.addEventListener('dragend', () => {
              taskBlock.classList.remove('is-dragging');
              clearDragState();
            });

            taskBlock.addEventListener('dblclick', () => {
              openTaskModal(dateKey, task);
            });

            taskBlock.addEventListener('keydown', (event) => {
              if (event.key === 'Enter') {
                event.preventDefault();
                openTaskModal(dateKey, task);
              }
            });

            timelineContent.appendChild(taskBlock);
          });

          timelineScroller.addEventListener('scroll', () => {
            timelineScroller.dataset.manualScroll = 'true';
          }, { once: true });

          timelineScroller.addEventListener('dragover', (event) => {
            if (!draggedTask) return;
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            cell.classList.add('drag-over');
          });

          timelineScroller.addEventListener('dragleave', (event) => {
            if (!timelineScroller.contains(event.relatedTarget)) {
              cell.classList.remove('drag-over');
            }
          });

          timelineScroller.addEventListener('drop', (event) => {
            if (!draggedTask) {
              clearDragState();
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            cell.classList.remove('drag-over');
            const rect = timelineContent.getBoundingClientRect();
            const offset = event.clientY - rect.top + timelineScroller.scrollTop;
            const pointerMinutes = Math.max(0, offset / TIMELINE_MINUTE_HEIGHT);
            const rounded = Math.round(pointerMinutes / 15) * 15;
            const duration = Math.max(1, Math.round(Number(draggedTask.duration) || 30));
            const maxStart = Math.max(0, MINUTES_IN_DAY - duration);
            const pointerOffset = Number(draggedTask.offsetMinutes) || 0;
            let startMinutes = Math.max(0, rounded - pointerOffset);
            startMinutes = Math.min(startMinutes, maxStart);
            const newStart = minutesToTime(startMinutes);
            moveTaskToDate(draggedTask, dateKey, { newStart });
            clearDragState();
          });

          cell.appendChild(timelineWrapper);

          requestAnimationFrame(() => {
            if (!timelineScroller.dataset.manualScroll) {
              const defaultMinutes = 8 * 60;
              const target = Math.max(0, defaultMinutes * TIMELINE_MINUTE_HEIGHT);
              timelineScroller.scrollTop = target;
            }
          });

          if (realTodayKey === dateKey) {
            const progress = document.createElement('div');
            progress.className = 'day-progress';
            cell.appendChild(progress);
          }

          monthGrid.appendChild(cell);
        }

        calendarGridEl.appendChild(monthBlock);
      });

      renderYearOverview();
      updateYearLabels();

      updateCurrentTime();
      updateFocusSelectionHighlight();

      if (!initialScrollCompleted) {
        initialScrollCompleted = true;
        const targetYear = viewDate.getFullYear();
        const targetMonth = viewDate.getMonth();
        requestAnimationFrame(() => {
          scrollMainCalendarToMonth(targetYear, targetMonth, { smooth: false });
        });
      }
    }

    function parseTimeToMinutes(value) {
      if (!value || typeof value !== 'string') return null;
      const [hoursRaw, minutesRaw] = value.split(':');
      const hours = Number(hoursRaw);
      const minutes = Number(minutesRaw);
      if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
      const total = hours * 60 + minutes;
      return Math.max(0, Math.min(MINUTES_IN_DAY - 1, total));
    }

    function minutesToTime(totalMinutes) {
      let normalized = Math.round(Number(totalMinutes) || 0);
      if (!Number.isFinite(normalized)) normalized = 0;
      normalized = ((normalized % MINUTES_IN_DAY) + MINUTES_IN_DAY) % MINUTES_IN_DAY;
      const hours = Math.floor(normalized / 60);
      const minutes = normalized % 60;
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }

    function formatHourLabel(hour) {
      const normalized = ((Number(hour) || 0) % 24 + 24) % 24;
      return `${String(normalized).padStart(2, '0')}:00`;
    }

    function computeEndTime(start, duration) {
      const parsed = parseTimeToMinutes(start);
      if (parsed == null) return start;
      const totalMinutes = parsed + Math.round(Math.max(0, Number(duration || 0)));
      return minutesToTime(totalMinutes);
    }

    function moveTaskToDate(taskInfo, newDateKey, options = {}) {
      const fromTasks = state.tasks[taskInfo.fromDate] || [];
      const taskIndex = fromTasks.findIndex((t) => t.id === taskInfo.id);
      if (taskIndex === -1) return;

      const [task] = fromTasks.splice(taskIndex, 1);
      if (options.newStart) {
        task.start = options.newStart;
      }
      if (!state.tasks[newDateKey]) state.tasks[newDateKey] = [];
      state.tasks[newDateKey].push(task);

      if (fromTasks.length === 0) {
        delete state.tasks[taskInfo.fromDate];
      }

      state.tasks[newDateKey].sort(compareTasks);
      saveState();
      renderCalendar();
    }

    document.getElementById('reset-calendar').addEventListener('click', () => {
      const now = new Date();
      viewDate = new Date(now.getFullYear(), now.getMonth(), 1);
      initialScrollCompleted = false;
      initialMiniScrollCompleted = false;
      renderCalendar();
      setTimeout(() => scrollToToday({ smooth: true }), 220);
      hideMiniTooltip();
    });

    yearNavButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const delta = Number(button.dataset.yearNav);
        if (Number.isNaN(delta)) return;
        const targetYear = viewDate.getFullYear() + delta;
        viewDate = new Date(targetYear, 0, 1);
        initialMiniScrollCompleted = false;
        renderCalendar();
        hideMiniTooltip();
      });
    });

    document.getElementById('add-focus').addEventListener('click', () => {
      openFocusModal(null);
    });

    taskCancelBtn.addEventListener('click', closeTaskModal);
    taskCategorySelect.addEventListener('change', () => {
      const value = taskCategorySelect.value;
      const isNew = value === '__new__';
      toggleNewCategoryFields(isNew);
      if (!isNew) {
        newCategoryNameInput.value = '';
        newCategoryColorInput.value = '';
      }
      renderCategoryPreview(getSortedCategories(), value);
      updateDeleteCategoryButtonState(value);
    });

    if (deleteCategoryBtn) {
      deleteCategoryBtn.addEventListener('click', () => {
        const selectedValue = taskCategorySelect.value;
        if (!selectedValue || selectedValue === '__new__' || selectedValue.toLowerCase() === 'general') {
          return;
        }
        if (!window.confirm(`Delete the "${selectedValue}" category? All tasks will be reassigned to General.`)) {
          return;
        }
        const index = state.categories.findIndex((category) => category.name === selectedValue);
        if (index === -1) return;
        const general = ensureGeneralCategoryExists();
        state.categories.splice(index, 1);
        Object.keys(state.tasks).forEach((dateKey) => {
          const tasks = state.tasks[dateKey];
          if (!Array.isArray(tasks)) return;
          tasks.forEach((task) => {
            if (task.category === selectedValue) {
              task.category = general.name;
            }
          });
        });
        populateCategorySelect(general.name);
        saveState();
        renderCalendar();
      });
    }

    focusCancelBtn.addEventListener('click', closeFocusModal);

    taskModalBackdrop.addEventListener('click', (event) => {
      if (event.target === taskModalBackdrop) {
        closeTaskModal();
      }
    });

    focusModalBackdrop.addEventListener('click', (event) => {
      if (event.target === focusModalBackdrop) {
        closeFocusModal();
      }
    });

    taskForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const formData = new FormData(taskForm);
      const title = formData.get('title').trim();
      if (!title) return;

      let categorySelection = formData.get('category');
      const isNewCategory = categorySelection === '__new__';
      let categoryName = isNewCategory ? (formData.get('newCategoryName') || '').trim() : (categorySelection || '').trim();

      if (isNewCategory) {
        if (!categoryName) {
          alert('Please provide a name for the new category.');
          return;
        }
        const existing = getCategoryByName(categoryName);
        if (existing) {
          categoryName = existing.name;
        } else {
          const colorValue = formData.get('newCategoryColor') || categoryPalette[0];
          const newCategory = { id: state.nextCategoryId++, name: categoryName, color: colorValue };
          state.categories.push(newCategory);
        }
      } else if (!categoryName) {
        categoryName = ensureGeneralCategoryExists().name;
      }

      const start = (formData.get('start') || '').trim();
      const durationRaw = formData.get('duration');
      let durationValue = null;
      if (durationRaw !== null && durationRaw !== '') {
        const parsed = Number(durationRaw);
        if (!Number.isFinite(parsed) || parsed < 0) {
          alert('Please provide a valid duration.');
          return;
        }
        durationValue = Math.round(parsed);
      }
      const notes = (formData.get('notes') || '').trim();

      const payload = {
        title,
        category: categoryName,
        missionCritical: Boolean(missionCriticalInput.checked)
      };

      if (start) payload.start = start;
      if (durationValue != null) payload.duration = durationValue;
      if (notes) payload.notes = notes;

      if (editingTask) {
        const tasks = ensureTasks(editingDate);
        const index = tasks.findIndex((task) => task.id === editingTask.id);
        if (index !== -1) {
          tasks[index] = { ...tasks[index], ...payload };
        }
      } else {
        const taskId = state.nextTaskId++;
        ensureTasks(editingDate).push({ id: taskId, ...payload });
      }

      ensureTasks(editingDate).sort(compareTasks);
      saveState();
      closeTaskModal();
      renderCalendar();
    });

    taskDeleteBtn.addEventListener('click', () => {
      if (!editingTask) return;
      const tasks = ensureTasks(editingDate);
      const index = tasks.findIndex((task) => task.id === editingTask.id);
      if (index !== -1) {
        tasks.splice(index, 1);
      }
      removeEmptyTaskLists(editingDate);
      saveState();
      closeTaskModal();
      renderCalendar();
    });

    focusForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const formData = new FormData(focusForm);
      const name = formData.get('name').trim();
      const start = formData.get('start');
      const end = formData.get('end');
      if (!name || !start || !end) return;

      if (end < start) {
        alert('The wrap date must be on or after the start date.');
        return;
      }

      const color = formData.get('color');

      if (editingFocusId != null) {
        const index = state.projects.findIndex((project) => project.id === editingFocusId);
        if (index !== -1) {
          state.projects[index] = { ...state.projects[index], name, start, end, color };
        }
      } else {
        const project = {
          id: state.nextProjectId++,
          name,
          start,
          end,
          color
        };
        state.projects.push(project);
      }

      saveState();
      closeFocusModal();
      renderCalendar();
    });

    focusDeleteBtn.addEventListener('click', () => {
      if (editingFocusId == null) return;
      const index = state.projects.findIndex((project) => project.id === editingFocusId);
      if (index !== -1) {
        state.projects.splice(index, 1);
      }
      saveState();
      closeFocusModal();
      renderCalendar();
    });

    function updateCurrentTime() {
      const now = new Date();
      currentDateEl.textContent = formatFullDate(now);
      currentTimeEl.textContent = formatTime(now);

      const todayKey = formatDateKey(now);
      const todayCell = calendarGridEl.querySelector(`.day[data-date="${todayKey}"]`);
      if (todayCell) {
        todayCell.classList.add('today');
        const progress = todayCell.querySelector('.day-progress');
        if (progress) {
          const minutes = now.getHours() * 60 + now.getMinutes();
          const percentage = Math.min(100, Math.max(0, (minutes / (24 * 60)) * 100));
          progress.style.width = `${percentage}%`;
        }
      }
    }

    setInterval(updateCurrentTime, 60 * 1000);

    renderCalendar();
  </script>
</body>
</html>
